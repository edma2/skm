#include "parser.h"
#include "env.h"

#define EXPR_MAX 1000
#define EVAL_ERR -1
#define EVAL_EXIT 1
#define EVAL_SUCCESS 0

int eval(List *environment, Tree *t, float *result);

int main(void) {
	Tree *t;
	float result;
	int retval;
	char buf[EXPR_MAX];
	Environment *global = Environment_new();
	Frame *current_frame;

	/* global frame */
	Environment_attach(global);
	current_frame = (Frame *)List_first(global)->data;

	printf("eval> ");
	while (fgets(buf, EXPR_MAX, stdin)) {
		/* parsing */
		buf[strlen(buf)-1] = '\0';
		if ((t = parse(buf)) == NULL) {
			/* if t fails then the malloc'd tree will already be freed by parse() */
			printf("eval> ");
			continue;
		}
		/* evaluation */
		retval = eval(environment, t, &result);
		/* we don't need t anymore */
		Tree_free(t);
		/* fail */
		if (retval == EVAL_ERR) {
			printf("eval> ");
			continue;
		}
		/* quit */
		else if (retval == EVAL_EXIT)
			break;
		/* success */
		printf("%f\n", result);
		printf("eval> ");
	}

	return 0;
}

/* lookup symbol in last frame of environment, add or change binding */
void addbind(List *environment, char *symbol, float *value) {
	Binding *b;
	Frame *f;
	float *val = malloc(sizeof(float)); /* save a copy of the value */

	/* check empty environment */
	if (environment == NULL || environment->head == NULL)
		return;
	*val = *value;
	/* frame to search in */
	f = (Frame *)List_last(environment)->data;
	/* search in current frame only */
	b = frame_search(f, symbol);
	/* add new binding */
	if (b == NULL)
		frame_bind(f, symbol, val);
	/* change existing */
	else 
		b->value = val;
}

/* store result in result, t is preserved */
int eval(List *environment, Tree *t, float *result) {
	Tree *tptr = Tree_first_child(t);
	Node *ptr;			
	List *arglist;		/* store argument list */
	char *proc; 		/* point to our procedure */
	float *n;		/* store our argument values so we can pass it to append() */
	Binding *bind;		/* lookup variable values go here */

	/* check if malloc succeeded */
	if ((arglist = List_new()) == NULL) {
		printf("error: memory error\n");
		return EVAL_ERR;
	}
	/* fetch the procedure */
	proc = tptr->datum;
	/* fetch arguments */
	for (tptr = Tree_next_sibling(tptr); tptr != NULL; tptr = Tree_next_sibling(tptr)) {
		if ((n = malloc(sizeof(float))) == NULL) {
			printf("error: memory error\n");
			return EVAL_ERR;
		}
		/* find real value if needed */
		if (tptr->datum == NULL) {
			if (eval(environment, tptr, result) == EVAL_ERR)
				return EVAL_ERR;
			*n = *result;
		}
		/* look up value (values must be float) */
		else {
			if ((bind = variable_lookup(environment, tptr->datum)) != NULL)
				*n = *(float *)bind->value;
			else 
				*n = atof(tptr->datum);
		}
		List_append(arglist, n);
	}

	if (proc == NULL) {
		printf("error: missing procedure\n");
		return EVAL_ERR;
	}

	/* show binded value */
	else if ((bind = variable_lookup(environment, proc)) != NULL && (arglist->length == 0))
		*result = *(float *)bind->value;
	/* elementary arithmetic */
	else if (!(strcmp(proc, "*"))) {
		if (arglist->length == 0) {
			printf("error: wrong number of arguments\n");
			return EVAL_ERR;
		}
		*result = *((float *)(List_first(arglist)->data));
		for (ptr = List_first(arglist)->next; ptr != NULL; ptr = ptr->next)
			*result *= *((float *)ptr->data);
	}
	else if (!(strcmp(proc, "+"))) {
		if (arglist->length == 0) {
			printf("error: wrong number of arguments\n");
			return EVAL_ERR;
		}
		*result = *((float *)(List_first(arglist)->data));
		for (ptr = List_first(arglist)->next; ptr != NULL; ptr = ptr->next)
			*result += *((float *)ptr->data);
	}
	else if (!(strcmp(proc, "-"))) {
		if (arglist->length == 0) {
			printf("error: wrong number of arguments\n");
			return EVAL_ERR;
		}
		*result = *((float *)(List_first(arglist)->data));
		for (ptr = List_first(arglist)->next; ptr != NULL; ptr = ptr->next)
			*result -= *((float *)ptr->data);
	}
	else if (!(strcmp(proc, "/"))) {
		if (arglist->length == 0) {
			printf("error: wrong number of arguments\n");
			return EVAL_ERR;
		}
		*result = *((float *)(List_first(arglist)->data));
		for (ptr = List_first(arglist)->next; ptr != NULL; ptr = ptr->next)
			*result /= *((float *)ptr->data);
	}
	/* quit */
	else if (!(strcmp(proc, "exit")))
		return EVAL_EXIT;
	/* define new binding or override existing one */
	else if (arglist->length == 1) {
		addbind(environment, proc, List_first(arglist)->data);
		*result = *(float *)List_first(arglist)->data;
	}
	else {
		printf("error: unsupported procedure \"%s\"\n", proc);
		return EVAL_ERR;
	}

	/* free the list we used */
	List_free(arglist);

	return EVAL_SUCCESS;
}
