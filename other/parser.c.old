#include "tree/tree.h"
#include <string.h>

#define MAXARG 			20

#define STATE_BEGIN 		0
#define STATE_OPEN_PAREN 	1
#define STATE_CLOSE_PAREN 	2
#define STATE_PROC 		3
#define STATE_ARG 		4
#define STATE_END 		5
#define STATE_ERROR 		6

#define TYPE_PROC 		0
#define TYPE_ARG 		1

Tree *parse(char *buf);
Tree *add_proc(Tree *t, char *proc, int layer);
Tree *add_arg(Tree *t, char *arg, int layer);
void print(Tree *t, int depth);

typedef struct {
	char word[MAXARG];
	int type;
	int level;
} Word;

int main(void) {
	Tree *t;

	t = parse("((x foo bar) 7 4 89 (* 2 3) )");
	print(t, 0);

	return 0;
}

void print(Tree *t, int depth) {
	Node *ptr;
	int d;

	for (d = depth; d > 0; d--)
		printf("- ");
	printf("\\");
	printf("%s:%d\n", ((Word *)t->datum)->word, ((Word *)t->datum)->level);
	for (ptr = t->children->head; ptr != NULL; ptr = ptr->next)
		print((Tree *)ptr->data, depth + 1);
}


Tree *parse(char *buf) {
	Tree *t = NULL;
	int state = STATE_BEGIN;	
	int layer = 0;
	int proc_layer;
	char *ptr = buf;
	char arg[MAXARG];
	int i = 0; 		

	memset(arg, 0, MAXARG);
	state = STATE_BEGIN;
	do {
		if (state == STATE_BEGIN) {
			/* go to first open paren */
			if (*ptr == '(') {
				layer++;
				printf("going up %d\n", layer);
				state = STATE_OPEN_PAREN;
			}
		}
		else if (state == STATE_OPEN_PAREN) {
			if (*ptr == ')')
				state = STATE_ERROR;
			else if (*ptr == '(') {
				layer++;
				printf("going up %d\n", layer);
				state = STATE_OPEN_PAREN;
			}
			else if (*ptr != ' ') {
				arg[i++] = *ptr;
				state = STATE_PROC;
				proc_layer = layer;
			}
		}


		else if (state == STATE_CLOSE_PAREN) {
			/* go to next arg */
			if (*ptr == ')') {
				layer--;
				printf("going down %d\n", layer);
				if (layer == 0)
					break;
				state = STATE_CLOSE_PAREN;
			}
			else if (*ptr == '(') {
				layer++;
				printf("going up %d\n", layer);
				state = STATE_OPEN_PAREN;
			}
			else if (*ptr != ' ') {
				arg[i++] = *ptr;
				state = STATE_ARG;
			}
		}
		else if (state == STATE_PROC) {
			/* we have a buffer ready to be stored */
			if (arg[0] != '\0' && (*ptr == ' ' || *ptr == ')')) {
				/* terminate string */
				arg[i] = '\0';
				/* store buffer */
				t = add_proc(t, arg, layer);
				printf("proc: %s\n", arg);
				/* reset buffer */
				i = 0;
				arg[0] = '\0';

				state = STATE_ARG;
				continue;
			}
			else if (*ptr == ')')
				layer--;
			else if (*ptr == '(')
				layer++;
			arg[i] == *ptr;
		}
		else if (state == STATE_PROC || STATE_ARG) {
			/* we have a buffer ready to be stored */
			if (arg[0] != '\0' && (*ptr == ' ' || *ptr == ')')) {
				/* terminate string */
				arg[i] = '\0';
				/* store buffer */
				t = (state == STATE_PROC) ? add_proc(t, arg, layer) : add_arg(t, arg, layer);
				printf("arg: %s\n", arg);
				/* reset buffer */
				i = 0;
				arg[0] = '\0';

				state = STATE_ARG;
			}
			if (*ptr == ')') {
				layer--;
				printf("going down %d\n", layer);
				if (layer == 0)
					break;
				/* t goes down a level */
				if (Tree_getParent(t) != NULL)
					t = Tree_getParent(t);
				state = STATE_CLOSE_PAREN;
			}
			/* TODO: if state PROC, copy everything into buffer until we see matching paren */
			else if (*ptr == '(') {
				layer++;
				printf("going up %d\n", layer);
				state = STATE_OPEN_PAREN;
			}
			else if (*ptr != ' ')
				arg[i++] = *ptr;
		}
		ptr++;
	} while (state != STATE_ERROR);

	if (state == STATE_ERROR) 
		printf("Something went wrong\n");

	return t;
}

Tree *add_proc(Tree *t, char *proc, int level) {
	Word *p = malloc(sizeof(Word));

	/* check if malloc succeeded */
	if (p == NULL || proc == NULL)
		return NULL;
	/* prep struct */
	strcpy(p->word, proc);
	p->type = TYPE_PROC;
	p->level = level;
	/* if first procedure */
	if (t == NULL)
		return Tree_new(p);

	/* return child tree */
	return Tree_addChild(t, p);
}

Tree *add_arg(Tree *t, char *arg, int level) {
	Word *a = malloc(sizeof(Word));

	/* check if malloc succeeded */
	if (a == NULL || arg == NULL || t == NULL)
		return NULL;
	/* prep struct */
	strcpy(a->word, arg);
	a->type = TYPE_ARG;
	a->level = level;

	Tree_addChild(t, a);

	/* return original tree */
	return t;
}
